package pe.edu.vallegrande.maintenancePayment.application.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.FindAndModifyOptions;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.stereotype.Service;
import pe.edu.vallegrande.maintenancePayment.domain.dto.PaymentDto;
import pe.edu.vallegrande.maintenancePayment.domain.model.Counter;
import pe.edu.vallegrande.maintenancePayment.domain.model.PaymentModel;
import pe.edu.vallegrande.maintenancePayment.domain.repository.PaymentRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.Date;

@Service
public class PaymentService {

    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);

    @Autowired
    private PaymentRepository paymentRepository;

    @Autowired
    private ExternalService externalService;

    @Autowired
    private MongoOperations mongoOperations;

    private static final String DATE_FORMAT = "dd-MMM-yyyy";

    private int getNextSequence(String seqName) {
        Query query = new Query(Criteria.where("_id").is(seqName));
        Update update = new Update().inc("sequence", 1);
        FindAndModifyOptions options = new FindAndModifyOptions().returnNew(true).upsert(true);
        Counter counter = mongoOperations.findAndModify(query, update, options, Counter.class);
        return counter.getSequence();
    }

    public Mono<PaymentDto> createPayment(PaymentDto paymentDto) {
        log.info("Creating payment with data: {}", paymentDto);

        if (paymentDto.getEnrollment() == null || paymentDto.getEnrollment().getId() == null) {
            log.error("Enrollment ID cannot be null");
            return Mono.error(new IllegalArgumentException("Enrollment ID cannot be null"));
        }

        return externalService.getEnrollmentById(paymentDto.getEnrollment().getId())
                .flatMap(enrollmentDto -> {
                    log.info("Enrollment data retrieved: {}", enrollmentDto);
                    paymentDto.setEnrollment(enrollmentDto);

                    // Set the current date in the required format
                    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);
                    paymentDto.setDate(sdf.format(new Date()));

                    // Ensure status is set to "A"
                    paymentDto.setStatus("A");

                    // Ensure amount has two decimal places
                    if (paymentDto.getAmount() != null) {
                        paymentDto.setAmount(paymentDto.getAmount().setScale(2, BigDecimal.ROUND_HALF_UP));
                    }

                    // Generate correlativo
                    int correlativo = getNextSequence("paymentSeq");
                    PaymentModel paymentModel = new PaymentModel(
                            null,  // ID will be generated by MongoDB
                            paymentDto.getAmount().toString(),
                            paymentDto.getDate(),
                            paymentDto.getEnrollment().getId(),
                            correlativo, // Set correlativo
                            paymentDto.getStatus()
                    );

                    log.info("Saving payment model: {}", paymentModel);

                    return paymentRepository.save(paymentModel)
                            .flatMap(savedPaymentModel -> {
                                log.info("Payment saved with ID: {}", savedPaymentModel.getId());
                                paymentDto.setId(savedPaymentModel.getId());  // Set the generated ID
                                paymentDto.setCorrelative(savedPaymentModel.getCorrelative()); // Set correlativo
                                return Mono.just(paymentDto);
                            });
                })
                .doOnError(error -> log.error("Error while creating payment: ", error));
    }

    public Mono<PaymentDto> updatePayment(String paymentId, PaymentDto paymentDto) {
        log.info("Updating payment with ID: {} and data: {}", paymentId, paymentDto);

        if (paymentId == null || paymentDto.getEnrollment() == null || paymentDto.getEnrollment().getId() == null) {
            log.error("Payment ID and Enrollment ID cannot be null");
            return Mono.error(new IllegalArgumentException("Payment ID and Enrollment ID cannot be null"));
        }

        return paymentRepository.findById(paymentId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Payment not found")))
                .flatMap(existingPayment -> externalService.getEnrollmentById(paymentDto.getEnrollment().getId())
                        .flatMap(enrollmentDto -> {
                            log.info("Enrollment data retrieved: {}", enrollmentDto);
                            paymentDto.setEnrollment(enrollmentDto);

                            // Ensure amount has two decimal places
                            if (paymentDto.getAmount() != null) {
                                paymentDto.setAmount(paymentDto.getAmount().setScale(2, BigDecimal.ROUND_HALF_UP));
                            }

                            // Set the current date in the required format
                            SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);
                            String currentDate = sdf.format(new Date());

                            // Generate new correlativo
                            int correlativo = getNextSequence("paymentSeq");

                            existingPayment.setAmount(paymentDto.getAmount().toString());
                            existingPayment.setDate(currentDate);
                            existingPayment.setEnrollmentId(paymentDto.getEnrollment().getId());
                            existingPayment.setStatus(paymentDto.getStatus());
                            existingPayment.setCorrelative(correlativo); // Set new correlativo

                            log.info("Saving updated payment model: {}", existingPayment);

                            return paymentRepository.save(existingPayment)
                                    .map(savedPaymentModel -> {
                                        log.info("Payment updated with ID: {}", savedPaymentModel.getId());
                                        paymentDto.setId(savedPaymentModel.getId());  // Set the generated ID
                                        paymentDto.setDate(currentDate);  // Set the updated date
                                        paymentDto.setCorrelative(savedPaymentModel.getCorrelative()); // Set new correlativo
                                        return paymentDto;
                                    });
                        }))
                .doOnError(error -> log.error("Error while updating payment: ", error));
    }

    public Flux<PaymentDto> listActivePayments() {
        return paymentRepository.findByStatus("A")
                .flatMap(this::convertToDtoWithEnrollment);
    }

    public Flux<PaymentDto> listInactivePayments() {
        return paymentRepository.findByStatus("I")
                .flatMap(this::convertToDtoWithEnrollment);
    }

    public Mono<PaymentDto> activatePayment(String paymentId) {
        return paymentRepository.findById(paymentId)
                .flatMap(payment -> {
                    payment.setStatus("A");
                    return paymentRepository.save(payment);
                })
                .flatMap(this::convertToDtoWithEnrollment);
    }

    public Mono<PaymentDto> deactivatePayment(String paymentId) {
        return paymentRepository.findById(paymentId)
                .flatMap(payment -> {
                    payment.setStatus("I");
                    return paymentRepository.save(payment);
                })
                .flatMap(this::convertToDtoWithEnrollment);
    }

    public Mono<PaymentDto> findPaymentById(String paymentId) {
        return paymentRepository.findById(paymentId)
                .flatMap(this::convertToDtoWithEnrollment);
    }

    public Mono<Void> deleteInactivePayment(String paymentId) {
        return paymentRepository.findById(paymentId)
                .flatMap(payment -> {
                    if ("I".equals(payment.getStatus())) {
                        return paymentRepository.delete(payment);
                    } else {
                        return Mono.error(new IllegalStateException("Cannot delete active payment"));
                    }
                });
    }

    private Mono<PaymentDto> convertToDtoWithEnrollment(PaymentModel paymentModel) {
        return externalService.getEnrollmentById(paymentModel.getEnrollmentId())
                .map(enrollmentDto -> {
                    PaymentDto paymentDto = new PaymentDto();
                    paymentDto.setId(paymentModel.getId());
                    paymentDto.setAmount(new BigDecimal(paymentModel.getAmount()));
                    paymentDto.setDate(paymentModel.getDate());
                    paymentDto.setStatus(paymentModel.getStatus());
                    paymentDto.setEnrollment(enrollmentDto);
                    paymentDto.setCorrelative(paymentModel.getCorrelative()); // Set correlativo
                    return paymentDto;
                });
    }
}